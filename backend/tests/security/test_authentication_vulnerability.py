#!/usr/bin/env python3
"""
Security tests to verify authentication vulnerabilities are fixed.

This test verifies that the X-User-ID header bypass vulnerability has been properly fixed.
"""

import pytest
from fastapi.testclient import TestClient
from fastapi import HTTPException
import jwt
import hmac
import time
from unittest.mock import patch, MagicMock
import os
import sys

# Add backend to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from api_server import app
from utils.authentication import get_authenticated_user_id


class TestAuthenticationSecurity:
    """Security tests for authentication bypass vulnerabilities."""
    
    def setup_method(self):
        """Set up test client."""
        self.client = TestClient(app)
        self.test_api_key = "test_api_key_123"
        
    def test_x_user_id_header_rejected(self):
        """
        SECURITY TEST: Verify X-User-ID headers are completely ignored.
        
        Previously, attackers could bypass authentication by sending:
        X-API-Key: shared_secret + X-User-ID: victim_user_id
        
        This should now be completely blocked.
        """
        # Attempt the old attack pattern
        headers = {
            "X-API-Key": self.test_api_key,
            "X-User-ID": "attacker_user_id_123",  # This should be IGNORED
        }
        
        # Try to access a protected endpoint
        response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
        
        # Should fail with 401 because no JWT token provided
        assert response.status_code == 401
        assert "JWT token required" in response.json().get("detail", "")
        
    def test_api_key_alone_insufficient(self):
        """
        SECURITY TEST: Verify API key alone cannot authenticate users.
        
        API keys should only verify service access, not user identity.
        """
        headers = {
            "X-API-Key": self.test_api_key,
            # No Authorization header with JWT token
        }
        
        response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
        
        # Should fail because JWT token is required for user identity
        assert response.status_code == 401
        
    def test_jwt_token_required_for_user_auth(self):
        """
        SECURITY TEST: Verify JWT tokens are required for user authentication.
        """
        # Create a mock valid JWT token
        mock_payload = {
            "sub": "user_123",
            "aud": "authenticated",
            "exp": 9999999999  # Far future
        }
        
        # Mock the JWT decode to return our test payload
        with patch('utils.authentication.jwt.decode') as mock_decode:
            mock_decode.return_value = mock_payload
            
            headers = {
                "X-API-Key": self.test_api_key,
                "Authorization": "Bearer valid_jwt_token_here"
            }
            
            # The request should now proceed to the next step (which may fail for other reasons)
            # but it should NOT fail with "JWT token required"
            response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
            
            # Should not be a JWT token error
            assert "JWT token required" not in response.json().get("detail", "")
            
    def test_malformed_jwt_rejected(self):
        """
        SECURITY TEST: Verify malformed JWT tokens are rejected.
        """
        headers = {
            "X-API-Key": self.test_api_key,
            "Authorization": "Bearer invalid_jwt_token"
        }
        
        response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
        
        # Should fail with 401 due to invalid JWT
        assert response.status_code == 401
        
    def test_expired_jwt_rejected(self):
        """
        SECURITY TEST: Verify expired JWT tokens are rejected.
        """
        # Mock JWT decode to raise ExpiredSignatureError
        with patch('utils.authentication.jwt.decode') as mock_decode:
            mock_decode.side_effect = jwt.ExpiredSignatureError("Token has expired")
            
            headers = {
                "X-API-Key": self.test_api_key,
                "Authorization": "Bearer expired_jwt_token"
            }
            
            response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
            
            # Should fail with 401 due to expired JWT
            assert response.status_code == 401
            
    def test_no_api_key_rejected(self):
        """
        SECURITY TEST: Verify requests without API keys are rejected.
        """
        headers = {
            "Authorization": "Bearer some_jwt_token"
            # No X-API-Key header
        }
        
        response = self.client.get("/api/portfolio/activities?account_id=test", headers=headers)
        
        # Should fail with 401 due to missing API key
        assert response.status_code == 401
        assert "API key missing" in response.json().get("detail", "")
        
    @patch.dict(os.environ, {'BACKEND_API_KEY': 'test_secret_key'})
    def test_authentication_service_unit_test(self):
        """
        UNIT TEST: Test the authentication service directly.
        """
        from utils.authentication import AuthenticationService
        
        # Test that API key validation returns None (no user identity)
        result = AuthenticationService.get_user_id_from_api_key("test_secret_key")
        assert result is None  # API key should NOT provide user identity
        
        # Test invalid API key
        result = AuthenticationService.get_user_id_from_api_key("wrong_key")
        assert result is None
        
    def test_timing_attack_prevention(self):
        """
        SECURITY TEST: Verify that constant-time comparison is used to prevent timing attacks.
        
        This test verifies that the API key comparison uses hmac.compare_digest
        instead of simple string comparison, which would be vulnerable to timing attacks.
        """
        from utils.authentication import AuthenticationService
        
        # Test with correct API key
        correct_key = "test_secret_key_123"
        wrong_key = "test_secret_key_124"  # One character different
        
        # Measure timing for correct key
        start_time = time.time()
        for _ in range(1000):
            AuthenticationService.get_user_id_from_api_key(correct_key)
        correct_time = time.time() - start_time
        
        # Measure timing for wrong key (should be similar due to constant-time comparison)
        start_time = time.time()
        for _ in range(1000):
            AuthenticationService.get_user_id_from_api_key(wrong_key)
        wrong_time = time.time() - start_time
        
        # The timing difference should be reasonable
        # If simple string comparison was used, wrong_key would be much faster
        # With constant-time comparison, timing should be similar or wrong_key might be slower
        timing_ratio = wrong_time / correct_time
        
        # Wrong key should not be significantly faster (which would indicate timing attack vulnerability)
        # Wrong key can be slower due to constant-time comparison
        assert wrong_time >= correct_time * 0.3, f"Wrong key too fast - potential timing attack: {timing_ratio}"
        
        # Timing should be within reasonable bounds (wrong key can be up to 10x slower)
        assert timing_ratio <= 10.0, f"Timing difference too large: {timing_ratio}"
        
    def test_constant_time_comparison_implementation(self):
        """
        SECURITY TEST: Verify that hmac.compare_digest is actually being used.
        
        This test mocks hmac.compare_digest to ensure it's being called
        instead of simple string comparison.
        """
        from utils.authentication import AuthenticationService
        
        with patch('utils.authentication.hmac.compare_digest') as mock_compare:
            mock_compare.return_value = True
            
            # Call the function
            AuthenticationService.get_user_id_from_api_key("test_key")
            
            # Verify hmac.compare_digest was called
            assert mock_compare.called
            mock_compare.assert_called_once()
            
    def test_api_key_comparison_uses_constant_time(self):
        """
        SECURITY TEST: Verify that both API key comparison locations use constant-time comparison.
        """
        from utils.authentication import get_authenticated_user_id
        from fastapi import Request
        
        # Mock the request and dependencies
        mock_request = MagicMock(spec=Request)
        
        with patch('utils.authentication.hmac.compare_digest') as mock_compare:
            mock_compare.return_value = False  # Invalid API key
            
            # This should call hmac.compare_digest for API key validation
            with pytest.raises(HTTPException) as exc_info:
                get_authenticated_user_id(mock_request, "wrong_key", None)
            
            # Verify hmac.compare_digest was called
            assert mock_compare.called
            assert exc_info.value.status_code == 401
        
    @patch.dict(os.environ, {'SUPABASE_JWT_SECRET': 'test_jwt_secret'})
    def test_jwt_authentication_unit_test(self):
        """
        UNIT TEST: Test JWT token authentication directly.
        """
        from utils.authentication import AuthenticationService
        
        # Mock a valid JWT payload
        mock_payload = {
            "sub": "user_123",
            "aud": "authenticated",
            "exp": 9999999999
        }
        
        with patch('utils.authentication.jwt.decode') as mock_decode:
            mock_decode.return_value = mock_payload
            
            result = AuthenticationService.get_user_id_from_auth_token("valid_token")
            assert result == "user_123"
            
        # Test invalid token
        with patch('utils.authentication.jwt.decode') as mock_decode:
            mock_decode.side_effect = jwt.InvalidTokenError("Invalid token")
            
            result = AuthenticationService.get_user_id_from_auth_token("invalid_token")
            assert result is None


if __name__ == "__main__":
    pytest.main([__file__, "-v"])