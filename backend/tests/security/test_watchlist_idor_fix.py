"""
Test: Watchlist IDOR Vulnerability Fix

Verifies that the watchlist endpoints properly enforce user authentication
and prevent Insecure Direct Object Reference (IDOR) attacks.

SECURITY: Tests that users can ONLY access their own watchlist data,
and cannot access other users' watchlists by manipulating request parameters.
"""

import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock
import jwt
import os
from datetime import datetime, timedelta

# These tests verify the security fix for watchlist endpoints


class TestWatchlistIDORFix:
    """
    Test suite for watchlist IDOR vulnerability fix.
    
    SECURITY: Ensures users can only access their own watchlist data
    and cannot access other users' data through parameter manipulation.
    """
    
    @pytest.fixture
    def api_key(self):
        """Valid API key for testing."""
        return os.getenv("BACKEND_API_KEY", "test-api-key")
    
    @pytest.fixture
    def user_a_token(self):
        """Generate a valid JWT token for user A."""
        # This would normally be generated by your auth system
        # For testing, we create a mock JWT token
        payload = {
            'sub': 'user-a-id',
            'email': 'user-a@example.com',
            'exp': datetime.utcnow() + timedelta(hours=1)
        }
        # In production, use your actual JWT secret
        secret = os.getenv("JWT_SECRET", "test-secret")
        return jwt.encode(payload, secret, algorithm='HS256')
    
    @pytest.fixture
    def user_b_token(self):
        """Generate a valid JWT token for user B."""
        payload = {
            'sub': 'user-b-id',
            'email': 'user-b@example.com',
            'exp': datetime.utcnow() + timedelta(hours=1)
        }
        secret = os.getenv("JWT_SECRET", "test-secret")
        return jwt.encode(payload, secret, algorithm='HS256')
    
    @pytest.fixture
    def mock_watchlist_service(self):
        """Mock the UserWatchlistService to avoid database calls."""
        with patch('backend.api_server.UserWatchlistService') as mock:
            # Configure mock responses
            mock.get_user_watchlist.return_value = ['AAPL', 'GOOGL', 'MSFT']
            mock.get_watchlist_details.return_value = {
                'watchlist_id': 'test-watchlist-id',
                'name': 'My Watchlist',
                'symbols': ['AAPL', 'GOOGL', 'MSFT'],
                'symbols_count': 3
            }
            mock.is_symbol_in_watchlist.return_value = False
            mock.add_symbol_to_watchlist.return_value = True
            mock.remove_symbol_from_watchlist.return_value = True
            yield mock
    
    def test_get_watchlist_requires_jwt_token(self, client: TestClient, api_key):
        """
        SECURITY TEST: Verify that GET /api/user/watchlist requires a JWT token.
        
        Expected: 401 Unauthorized without valid JWT token
        """
        response = client.get(
            "/api/user/watchlist",
            headers={"X-API-Key": api_key}
        )
        
        assert response.status_code == 401
        assert "Authentication required" in response.json()["detail"]
    
    def test_get_watchlist_rejects_invalid_jwt(self, client: TestClient, api_key):
        """
        SECURITY TEST: Verify that GET /api/user/watchlist rejects invalid JWT tokens.
        
        Expected: 401 Unauthorized with invalid JWT token
        """
        response = client.get(
            "/api/user/watchlist",
            headers={
                "X-API-Key": api_key,
                "Authorization": "Bearer invalid-jwt-token"
            }
        )
        
        assert response.status_code == 401
    
    def test_get_watchlist_with_valid_jwt(
        self, 
        client: TestClient, 
        api_key, 
        user_a_token,
        mock_watchlist_service
    ):
        """
        SECURITY TEST: Verify that GET /api/user/watchlist returns data for the 
        authenticated user (from JWT token).
        
        Expected: 200 OK with user's watchlist data
        """
        response = client.get(
            "/api/user/watchlist",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_a_token}"
            }
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "symbols" in data
        assert isinstance(data["symbols"], list)
        
        # Verify the service was called with the correct user_id from JWT
        mock_watchlist_service.get_user_watchlist.assert_called_once()
        call_args = mock_watchlist_service.get_user_watchlist.call_args[0]
        assert call_args[0] == 'user-a-id'  # User ID from JWT token
    
    def test_add_to_watchlist_requires_jwt(self, client: TestClient, api_key):
        """
        SECURITY TEST: Verify that POST /api/user/watchlist/add requires JWT token.
        
        Expected: 401 Unauthorized without valid JWT token
        """
        response = client.post(
            "/api/user/watchlist/add",
            headers={"X-API-Key": api_key},
            json={"symbol": "AAPL"}
        )
        
        assert response.status_code == 401
        assert "Authentication required" in response.json()["detail"]
    
    def test_add_to_watchlist_with_valid_jwt(
        self,
        client: TestClient,
        api_key,
        user_a_token,
        mock_watchlist_service
    ):
        """
        SECURITY TEST: Verify that POST /api/user/watchlist/add adds symbol
        to the authenticated user's watchlist (from JWT token).
        
        Expected: 200 OK with success message
        """
        response = client.post(
            "/api/user/watchlist/add",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_a_token}"
            },
            json={"symbol": "AAPL"}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert "AAPL" in data["message"]
        
        # Verify the service was called with the correct user_id from JWT
        mock_watchlist_service.add_symbol_to_watchlist.assert_called_once()
        call_args = mock_watchlist_service.add_symbol_to_watchlist.call_args[0]
        assert call_args[0] == 'user-a-id'  # User ID from JWT token
        assert call_args[1] == 'AAPL'
    
    def test_remove_from_watchlist_requires_jwt(self, client: TestClient, api_key):
        """
        SECURITY TEST: Verify that DELETE /api/user/watchlist/remove requires JWT token.
        
        Expected: 401 Unauthorized without valid JWT token
        """
        response = client.delete(
            "/api/user/watchlist/remove",
            headers={"X-API-Key": api_key},
            json={"symbol": "AAPL"}
        )
        
        assert response.status_code == 401
        assert "Authentication required" in response.json()["detail"]
    
    def test_remove_from_watchlist_with_valid_jwt(
        self,
        client: TestClient,
        api_key,
        user_a_token,
        mock_watchlist_service
    ):
        """
        SECURITY TEST: Verify that DELETE /api/user/watchlist/remove removes symbol
        from the authenticated user's watchlist (from JWT token).
        
        Expected: 200 OK with success message
        """
        # First, mark symbol as existing in watchlist
        mock_watchlist_service.is_symbol_in_watchlist.return_value = True
        
        response = client.delete(
            "/api/user/watchlist/remove",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_a_token}"
            },
            json={"symbol": "AAPL"}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert "AAPL" in data["message"]
        
        # Verify the service was called with the correct user_id from JWT
        mock_watchlist_service.remove_symbol_from_watchlist.assert_called_once()
        call_args = mock_watchlist_service.remove_symbol_from_watchlist.call_args[0]
        assert call_args[0] == 'user-a-id'  # User ID from JWT token
        assert call_args[1] == 'AAPL'
    
    def test_different_users_get_different_watchlists(
        self,
        client: TestClient,
        api_key,
        user_a_token,
        user_b_token,
        mock_watchlist_service
    ):
        """
        SECURITY TEST: Verify that different users get their own watchlists,
        not each other's data.
        
        CRITICAL: This test ensures the IDOR vulnerability is fixed.
        """
        # Configure different responses for different users
        def get_watchlist_for_user(user_id):
            if user_id == 'user-a-id':
                return ['AAPL', 'GOOGL']
            elif user_id == 'user-b-id':
                return ['TSLA', 'NVDA']
            return []
        
        mock_watchlist_service.get_user_watchlist.side_effect = get_watchlist_for_user
        
        # User A requests their watchlist
        response_a = client.get(
            "/api/user/watchlist",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_a_token}"
            }
        )
        
        # User B requests their watchlist
        response_b = client.get(
            "/api/user/watchlist",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_b_token}"
            }
        )
        
        assert response_a.status_code == 200
        assert response_b.status_code == 200
        
        # Verify the service was called with the correct user IDs
        calls = mock_watchlist_service.get_user_watchlist.call_args_list
        assert len(calls) == 2
        assert calls[0][0][0] == 'user-a-id'  # First call was for user A
        assert calls[1][0][0] == 'user-b-id'  # Second call was for user B
    
    def test_cannot_specify_user_id_in_url(self, client: TestClient, api_key, user_a_token):
        """
        SECURITY TEST: Verify that the old vulnerable endpoint pattern no longer exists.
        
        The old endpoint /api/user/{user_id}/watchlist should not exist.
        Expected: 404 Not Found
        """
        # Try to access the old vulnerable endpoint
        response = client.get(
            "/api/user/victim-user-id/watchlist",
            headers={
                "X-API-Key": api_key,
                "Authorization": f"Bearer {user_a_token}"
            }
        )
        
        # Should get 404 because this endpoint no longer exists
        assert response.status_code == 404


def test_summary():
    """
    SECURITY FIX SUMMARY
    ====================
    
    This test suite verifies that the IDOR vulnerability in watchlist endpoints
    has been properly fixed.
    
    BEFORE FIX (VULNERABLE):
    - Endpoints accepted user_id as URL path parameter
    - Only validated API key, not user identity
    - Any caller with valid API key could access ANY user's watchlist
    
    AFTER FIX (SECURE):
    - Endpoints derive user_id from JWT token only
    - Both API key AND JWT token must be valid
    - Users can ONLY access their own watchlist data
    
    TESTS VERIFY:
    ✅ JWT token is required for all watchlist operations
    ✅ Invalid JWT tokens are rejected
    ✅ User ID is extracted from JWT token, not URL
    ✅ Different users get different watchlist data
    ✅ Old vulnerable endpoint pattern no longer exists
    """
    pass


if __name__ == "__main__":
    print(__doc__)
    print(test_summary.__doc__)
