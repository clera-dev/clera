commit 45ee0be3a7a69121a4b23e35f9d59e2d5dbac23b
Author: Rishthegod <rishit.on.mail@gmail.com>
Date:   Tue Oct 7 16:28:55 2025 -0700

    Commit changes from dev-runbook-update before merge

diff --git a/backend/activate.sh b/backend/activate.sh
old mode 100644
new mode 100755
diff --git a/backend/clera_agents/financial_analyst_agent.py b/backend/clera_agents/financial_analyst_agent.py
index 24a70d4..d56057e 100644
--- a/backend/clera_agents/financial_analyst_agent.py
+++ b/backend/clera_agents/financial_analyst_agent.py
@@ -83,7 +83,20 @@ deep_research_perplexity = ChatPerplexity(
 )
 
 # Initialize Perplexity client for web search
-pplx_client = Perplexity() 
+pplx_client = Perplexity()
+
+# Global variable to store citations from web search
+_last_web_search_citations = []
+
+def get_last_web_search_citations():
+    """Get the citations from the last web search."""
+    global _last_web_search_citations
+    return _last_web_search_citations.copy()
+
+def clear_web_search_citations():
+    """Clear the citations from the last web search."""
+    global _last_web_search_citations
+    _last_web_search_citations = [] 
 @tool("web_search")
 def web_search(query: str) -> str:
     """Simple one-step search tool for financial information.
@@ -133,14 +146,23 @@ Query: {query}
         answer_text = response.choices[0].message.content  # The answer text
         citations = getattr(response, "citations", None)   # List of source URLs (if present)
 
-        # If citations are available, embed them as Markdown footnote links [1](url)
+        # Store citations in a global variable for metadata extraction
+        # This is a workaround since LangChain tools don't support metadata return
+        global _last_web_search_citations
+        _last_web_search_citations = citations if citations else []
+        
+        # Return clean text without embedded citations
+        # Remove any existing citation markers from the text
+        import re
+        # Remove [1], [2], etc. markers but keep the content
+        clean_text = re.sub(r'\[\d+\]', '', answer_text)
+        
+        # If we have citations, append them as a special marker that the streaming service can detect
         if citations:
-            for idx, url in enumerate(citations, start=1):
-                # Replace bracketed number with markdown link
-                footnote = f"[{idx}]"
-                link = f"[{idx}]({url})"
-                answer_text = answer_text.replace(footnote, link)
-        return answer_text
+            citation_marker = f"\n\n<!-- CITATIONS: {','.join(citations)} -->"
+            return clean_text + citation_marker
+        
+        return clean_text
     except Exception as e:
         return f"Error searching for information: {e}"
 
@@ -207,21 +229,30 @@ Query: {query}
         
         # Get citations from the final response if available
         try:
-            # Note: Citations might not be available in streaming mode
-            # We'll need to handle this based on Perplexity's streaming API behavior
-            pass
-        except:
-            pass
+            # For streaming, we need to make a separate non-streaming call to get citations
+            # This is a limitation of Perplexity's streaming API
+            non_stream_response = pplx_client.chat.completions.create(messages=messages, model=model_name, stream=False)
+            citations = getattr(non_stream_response, "citations", None)
+        except Exception as e:
+            print(f"Warning: Could not retrieve citations from streaming response: {e}")
+            citations = None
 
-        # If citations are available, embed them as Markdown footnote links [1](url)
+        # Store citations in a global variable for metadata extraction
+        global _last_web_search_citations
+        _last_web_search_citations = citations if citations else []
+        
+        # Return clean text without embedded citations
+        # Remove any existing citation markers from the text
+        import re
+        # Remove [1], [2], etc. markers but keep the content
+        clean_text = re.sub(r'\[\d+\]', '', answer_text)
+        
+        # If we have citations, append them as a special marker that the streaming service can detect
         if citations:
-            for idx, url in enumerate(citations, start=1):
-                # Replace bracketed number with markdown link
-                footnote = f"[{idx}]"
-                link = f"[{idx}]({url})"
-                answer_text = answer_text.replace(footnote, link)
+            citation_marker = f"\n\n<!-- CITATIONS: {','.join(citations)} -->"
+            return clean_text + citation_marker
         
-        return answer_text
+        return clean_text
     except Exception as e:
         return f"Error searching for information: {e}"
 
diff --git a/backend/requirements.txt b/backend/requirements.txt
index 941f37a..fd0a90b 100644
--- a/backend/requirements.txt
+++ b/backend/requirements.txt
@@ -109,7 +109,7 @@ orjson>=3.10.16
 ormsgpack>=1.10.0
 packaging>=24.2
 pandas>=2.2.3
-perplexityai>=1.0.0
+perplexityai>=0.13.0
 pillow>=11.2.1
 pinecone>=6.0.2
 pinecone-plugin-inference>=3.1.0
diff --git a/backend/utils/prompts/supervisor_prompt.py b/backend/utils/prompts/supervisor_prompt.py
index cf7281f..cebc5a0 100644
--- a/backend/utils/prompts/supervisor_prompt.py
+++ b/backend/utils/prompts/supervisor_prompt.py
@@ -122,6 +122,7 @@ When agents provide information, Clera MUST synthesize and present the findings
 
 **CRITICAL**: NEVER return empty responses or just agent names. ALWAYS provide substantive analysis.
 
+
 When synthesizing multi-agent information:
 - **Lead with specific data**: Actual numbers, percentages, dollar amounts
 - **Connect to user's situation**: Reference their current holdings/goals
diff --git a/frontend-app/components/chat/Chat.tsx b/frontend-app/components/chat/Chat.tsx
index 0f95fd9..758bdc7 100644
--- a/frontend-app/components/chat/Chat.tsx
+++ b/frontend-app/components/chat/Chat.tsx
@@ -26,6 +26,7 @@ import QueryLimitPopup from './QueryLimitPopup';
 import { createTimelineBuilder, TimelineBuilder } from '@/utils/services/TimelineBuilder';
 import { PerMessageToolDetails } from './PerMessageToolDetails';
 import { ChatMessageList } from './ChatMessageList';
+import SourcesTab from './SourcesTab';
 import { useToolActivitiesHydration } from '@/hooks/useToolActivitiesHydration';
 import { useRunIdAssignment } from '@/hooks/useRunIdAssignment';
 import { useQueryLimit } from '@/hooks/useQueryLimit';
@@ -75,6 +76,9 @@ export default function Chat({
   const [pendingFirstMessage, setPendingFirstMessage] = useState<string | null>(null);
   const [isFirstMessageSent, setIsFirstMessageSent] = useState(false); // New state to prevent duplicates
   const [messages, setMessages] = useState<Message[]>(initialMessages);
+  const [showSources, setShowSources] = useState(false);
+  const [currentRequestId, setCurrentRequestId] = useState<string | null>(null);
+  const [cachedCitations, setCachedCitations] = useState<string[]>([]); // Persisted citations cache
   const autoSubmissionTriggered = useRef(false); // Track if auto-submission has been triggered for this prompt
   
   // Mobile detection state
@@ -140,6 +144,101 @@ export default function Chat({
   const interruptMessage = interrupt?.value || null;
   const toolActivities = chatClient.state.toolActivities;
   
+  // Sources tab starts collapsed by default - user can manually toggle
+  
+  // Track current request ID for citation isolation
+  useEffect(() => {
+    const currentRunId = chatClient.getCurrentRunId();
+    if (currentRunId && currentRunId !== currentRequestId) {
+      setCurrentRequestId(currentRunId);
+      setShowSources(false); // Hide sources tab for new request
+    }
+  }, [chatClient, currentRequestId]);
+  
+  // Get citations from the current request or chat history
+  const getCurrentRequestCitations = () => {
+    const messages = chatClient.state.messages;
+    if (messages.length === 0) return [];
+    
+    // If we have a current request ID, only consider citations from that request
+    if (currentRequestId) {
+      for (let i = messages.length - 1; i >= 0; i--) {
+        const message = messages[i];
+        if (
+          message.role === 'assistant' &&
+          message.runId === currentRequestId &&
+          message.citations &&
+          message.citations.length > 0
+        ) {
+          return message.citations;
+        }
+      }
+      // No citations found for the current request – do NOT fall back to previous ones
+      return [];
+    }
+    // No active request (e.g., viewing chat history) – fall back to last assistant message with citations
+    for (let i = messages.length - 1; i >= 0; i--) {
+      const message = messages[i];
+      if (
+        message.role === 'assistant' &&
+        message.citations &&
+        message.citations.length > 0
+      ) {
+        return message.citations;
+      }
+    }
+    return [];
+  };
+
+  // Memo-ise citations to avoid unnecessary calculations
+  const currentCitations = getCurrentRequestCitations();
+
+  // Cache citations for up to 3 recent chats in localStorage
+  useEffect(() => {
+    if (currentThreadId && currentCitations.length > 0) {
+      try {
+        const raw = localStorage.getItem('clera_citation_cache');
+        const cache: Record<string, string[]> = raw ? JSON.parse(raw) : {};
+        cache[currentThreadId] = currentCitations;
+        const keys = Object.keys(cache);
+        if (keys.length > 3) {
+          // Evict oldest keys to keep cache size <= 3
+          const excess = keys.length - 3;
+          keys.slice(0, excess).forEach(k => delete cache[k]);
+        }
+        localStorage.setItem('clera_citation_cache', JSON.stringify(cache));
+      } catch (e) {
+        console.warn('Failed to persist citations cache:', e);
+      }
+    }
+  }, [currentThreadId, currentCitations]);
+
+  // Load cached citations when switching to a chat that may not have them in memory yet
+  useEffect(() => {
+    if (currentThreadId) {
+      try {
+        const raw = localStorage.getItem('clera_citation_cache');
+        const cache: Record<string, string[]> = raw ? JSON.parse(raw) : {};
+        const cached = cache[currentThreadId] || [];
+        setCachedCitations(cached);
+        if (cached.length > 0) {
+          setShowSources(true);
+        }
+      } catch {
+        setCachedCitations([]);
+      }
+    } else {
+      setCachedCitations([]);
+    }
+  }, [currentThreadId]);
+
+  // Automatically hide the Sources tab if there are no citations
+  useEffect(() => {
+    if (currentCitations.length === 0 && showSources) {
+      setShowSources(false);
+    }
+  }, [currentCitations, showSources]);
+  
   // Use retry popup state from the hook
   const shouldShowRetryPopup = messageRetry.shouldShowRetryPopup;
 
@@ -184,9 +283,18 @@ export default function Chat({
             return; // Keep existing messages (user input + status)
           }
           
-          chatClient.setMessages(threadMessages);
-          // PRODUCTION FIX: Clear any persistent errors when loading existing chat
-          chatClient.clearErrorOnChatLoad();
+        chatClient.setMessages(threadMessages);
+        // PRODUCTION FIX: Clear any persistent errors when loading existing chat
+        chatClient.clearErrorOnChatLoad();
+        // Clear current request ID when loading existing chat (no active request)
+        setCurrentRequestId(null);
+        // Show sources from the last assistant message in this chat if any
+        const hasCitations = threadMessages.some(msg => 
+          msg.role === 'assistant' && msg.citations && msg.citations.length > 0
+        );
+        if (hasCitations) {
+          setShowSources(true); // Auto-show sources for chat history with citations
+        }
         } catch (error) {
           console.error(`Failed to load messages for thread ${currentThreadId}:`, error);
           // Fall back to initial messages if thread loading fails
@@ -618,6 +726,9 @@ export default function Chat({
         setIsFirstMessageSent(false);
         autoSubmissionTriggered.current = false; // Reset auto-submission flag for new chat
         chatClient.setMessages([]); // Clear messages immediately
+        chatClient.clearCitations(); // Clear citations for new chat
+        setCurrentRequestId(null); // Clear current request ID for new chat
+        setShowSources(false); // Hide sources tab for new chat
         return; // Don't proceed with normal logic
       }
       
@@ -709,6 +820,13 @@ export default function Chat({
           isSidebarMode={isSidebarMode}
           timelineBuilder={timelineBuilder}
         />
+        
+        {/* Sources Tab - ChatGPT style */}
+        <SourcesTab
+          citations={currentCitations.length > 0 ? currentCitations : cachedCitations}
+          isVisible={showSources}
+          onToggle={() => setShowSources(!showSources)}
+        />
 
         
         {isInterrupting && interrupt && (
diff --git a/frontend-app/components/chat/SourcesTab.tsx b/frontend-app/components/chat/SourcesTab.tsx
new file mode 100644
index 0000000..b2b2723
--- /dev/null
+++ b/frontend-app/components/chat/SourcesTab.tsx
@@ -0,0 +1,163 @@
+'use client';
+
+import React, { useState, useEffect } from 'react';
+import { Badge } from '@/components/ui/badge';
+import { ExternalLink, ChevronDown, ChevronUp, Link2 } from 'lucide-react';
+import { cn } from '@/lib/utils';
+
+interface SourcesTabProps {
+  citations: string[];
+  isVisible: boolean;
+  onToggle: () => void;
+}
+
+export default function SourcesTab({ citations, isVisible, onToggle }: SourcesTabProps) {
+  const [isAnimating, setIsAnimating] = useState(false);
+
+  useEffect(() => {
+    if (isVisible) {
+      setIsAnimating(true);
+      const timer = setTimeout(() => setIsAnimating(false), 300);
+      return () => clearTimeout(timer);
+    }
+  }, [isVisible]);
+
+  if (!citations || citations.length === 0) {
+    return null;
+  }
+
+  const getDomainFromUrl = (url: string): string => {
+    try {
+      const domain = new URL(url).hostname.replace(/^www\./, '');
+      return domain;
+    } catch {
+      return url;
+    }
+  };
+
+  const getSourceTitle = (url: string): string => {
+    try {
+      const domain = new URL(url).hostname.replace(/^www\./, '');
+      return domain.split('.').map(word => 
+        word.charAt(0).toUpperCase() + word.slice(1)
+      ).join(' ');
+    } catch {
+      return url;
+    }
+  };
+
+  return (
+    <div className="mt-3">
+      {/* Compact Sources Button - ChatGPT style with Aceternity UI inspiration */}
+      <button
+        onClick={onToggle}
+        className={cn(
+          "inline-flex items-center gap-2 px-4 py-2 rounded-full text-sm font-medium transition-all duration-300",
+          "bg-gradient-to-r from-gray-50 to-gray-100 hover:from-gray-100 hover:to-gray-200",
+          "dark:from-gray-800 dark:to-gray-900 dark:hover:from-gray-700 dark:hover:to-gray-800",
+          "border border-gray-200 dark:border-gray-700",
+          "hover:shadow-lg hover:shadow-gray-200/50 dark:hover:shadow-gray-900/50",
+          "hover:scale-[1.02] active:scale-[0.98] transform-gpu",
+          "group relative overflow-hidden"
+        )}
+      >
+        {/* Animated background gradient */}
+        <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
+        
+        <Link2 className="h-4 w-4 text-gray-600 dark:text-gray-400 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-all duration-300 relative z-10" />
+        <span className="text-gray-700 dark:text-gray-300 group-hover:text-blue-700 dark:group-hover:text-blue-300 transition-colors duration-300 relative z-10">
+          Sources
+        </span>
+        <Badge 
+          variant="secondary" 
+          className="text-xs bg-gradient-to-r from-blue-100 to-blue-200 text-blue-700 dark:from-blue-900/30 dark:to-blue-800/30 dark:text-blue-300 px-2 py-1 rounded-full shadow-sm relative z-10"
+        >
+          {citations.length}
+        </Badge>
+        <div className="relative z-10">
+          {isVisible ? (
+            <ChevronUp className="h-4 w-4 text-gray-500 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-all duration-300" />
+          ) : (
+            <ChevronDown className="h-4 w-4 text-gray-500 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-all duration-300" />
+          )}
+        </div>
+      </button>
+
+      {/* Compact Sources List with smooth animations */}
+      <div
+        className={cn(
+          "mt-3 space-y-2 max-h-64 overflow-y-auto transition-all duration-300 ease-out",
+          isVisible 
+            ? "opacity-100 max-h-64 translate-y-0" 
+            : "opacity-0 max-h-0 -translate-y-2 pointer-events-none"
+        )}
+      >
+        {citations.map((citation, index) => (
+          <div
+            key={index}
+            className={cn(
+              "group flex items-center gap-3 p-3 rounded-xl transition-all duration-300",
+              "bg-gradient-to-r from-gray-50 to-gray-100 hover:from-gray-100 hover:to-gray-200",
+              "dark:from-gray-800/50 dark:to-gray-900/50 dark:hover:from-gray-800 dark:hover:to-gray-900",
+              "border border-gray-200 dark:border-gray-700",
+              "hover:shadow-lg hover:shadow-gray-200/50 dark:hover:shadow-gray-900/50",
+              "hover:scale-[1.02] transform-gpu",
+              "relative overflow-hidden"
+            )}
+            style={{
+              animationDelay: `${index * 50}ms`,
+              animation: isVisible ? 'fadeInUp 0.3s ease-out forwards' : 'none'
+            }}
+          >
+            {/* Animated background on hover */}
+            <div className="absolute inset-0 bg-gradient-to-r from-blue-500/5 to-purple-500/5 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
+            
+            <div className="flex-1 min-w-0 relative z-10">
+              <div className="flex items-center gap-3">
+                <div className="w-2.5 h-2.5 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 flex-shrink-0 shadow-sm" />
+                <span className="text-sm font-semibold text-gray-800 dark:text-gray-200 truncate">
+                  {getSourceTitle(citation)}
+                </span>
+              </div>
+              <div className="text-xs text-gray-500 dark:text-gray-400 truncate mt-1 ml-5">
+                {getDomainFromUrl(citation)}
+              </div>
+            </div>
+            <a
+              href={citation}
+              target="_blank"
+              rel="noopener noreferrer"
+              className={cn(
+                "flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-all duration-300",
+                "bg-gradient-to-r from-blue-50 to-blue-100 hover:from-blue-100 hover:to-blue-200",
+                "text-blue-700 hover:text-blue-800",
+                "dark:from-blue-900/20 dark:to-blue-800/20 dark:hover:from-blue-900/30 dark:hover:to-blue-800/30",
+                "dark:text-blue-300 dark:hover:text-blue-200",
+                "hover:shadow-md hover:scale-105 active:scale-95 transform-gpu",
+                "opacity-0 group-hover:opacity-100 translate-x-2 group-hover:translate-x-0",
+                "relative z-10"
+              )}
+              onClick={(e) => e.stopPropagation()}
+            >
+              <ExternalLink className="h-3.5 w-3.5" />
+              <span>Visit</span>
+            </a>
+          </div>
+        ))}
+      </div>
+
+      <style jsx>{`
+        @keyframes fadeInUp {
+          from {
+            opacity: 0;
+            transform: translateY(10px);
+          }
+          to {
+            opacity: 1;
+            transform: translateY(0);
+          }
+        }
+      `}</style>
+    </div>
+  );
+}
diff --git a/frontend-app/utils/api/chat-client.ts b/frontend-app/utils/api/chat-client.ts
index 1ea4d56..f3c5561 100644
--- a/frontend-app/utils/api/chat-client.ts
+++ b/frontend-app/utils/api/chat-client.ts
@@ -9,6 +9,7 @@ export type Message = {
   content: string;
   isStatus?: boolean; // For temporary status/progress messages
   runId?: string; // Anchor tool activities to a specific user query
+  citations?: string[]; // Citations for this specific message
 };
 
 export type ChatRequest = {
diff --git a/frontend-app/utils/api/secure-chat-client.ts b/frontend-app/utils/api/secure-chat-client.ts
index edd2a39..9903374 100644
--- a/frontend-app/utils/api/secure-chat-client.ts
+++ b/frontend-app/utils/api/secure-chat-client.ts
@@ -32,6 +32,8 @@ export interface SecureChatClient {
   clearLongProcessingCallback: () => void; // MEMORY LEAK FIX: Clear callback on unmount
   setQuerySuccessCallback: (callback: (userId: string) => Promise<void>) => void; // NEW: Query success recording
   cleanup: () => void;
+  clearCitations: () => void; // NEW: Clear citations for new chat
+  getCurrentRunId: () => string | null; // NEW: Get current run ID for request tracking
 }
 
 // ToolActivity is defined centrally in '@/types/chat'.
@@ -59,6 +61,7 @@ export class SecureChatClientImpl implements SecureChatClient {
   private querySuccessCallback: ((userId: string) => Promise<void>) | null = null; // NEW: Query success callback
   private lastThreadId: string | null = null; // Track thread for toolActivities lifecycle
   private currentQueryRunId: string | null = null; // Track current user query for tool grouping
+  private currentRequestCitations: string[] = []; // Store citations for current request
   
 
   constructor() {
@@ -364,7 +367,8 @@ export class SecureChatClientImpl implements SecureChatClient {
         this.gracePeriodTimer = null;
       }
       
-      this.setState({ isLoading: true, error: null });
+      this.setState({ isLoading: true, error: null }); // Reset state for each new request
+      this.currentRequestCitations = []; // Clear current request citations
       
       // Status message is now added by the caller before startStream is called
       // This prevents timing issues with React batching
@@ -716,6 +720,14 @@ export class SecureChatClientImpl implements SecureChatClient {
       const nodeName = chunk.data.nodeName;
       // console.log(`[SecureChatClient] Node update for: ${nodeName}, hasReceivedRealContent: ${this.hasReceivedRealContent}`);
       
+      // Extract citations from node updates (tool responses)
+      const newCitations = chunk.metadata?.citations || [];
+      if (newCitations.length > 0) {
+        // Store citations temporarily for the current request
+        // They will be attached to the final assistant message when the response is complete
+        this.currentRequestCitations = newCitations;
+      }
+      
       // CRITICAL FIX: Only show status messages if we haven't received real content yet
       // This prevents status messages from overriding completed responses
       if (!this.hasReceivedRealContent) {
@@ -834,9 +846,27 @@ export class SecureChatClientImpl implements SecureChatClient {
         // Mark that we've received real content BEFORE state update
         this.hasReceivedRealContent = true;
         
+        // Extract citations from metadata if available
+        const newCitations = chunk.metadata?.citations || [];
+        
+        // Combine with any citations from tool responses during this request
+        const allCitations = Array.from(new Set([...this.currentRequestCitations, ...newCitations]));
+        
+        // Attach citations to the last assistant message
+        const messagesWithCitations = [...newMessages];
+        if (messagesWithCitations.length > 0 && allCitations.length > 0) {
+          const lastMessage = messagesWithCitations[messagesWithCitations.length - 1];
+          if (lastMessage.role === 'assistant') {
+            lastMessage.citations = allCitations;
+          }
+        }
+        
+        // Clear current request citations after attaching them
+        this.currentRequestCitations = [];
+        
         // Update state with all new messages, ensuring status messages are removed
         this.setState({ 
-          messages: [...nonStatusMessages, ...newMessages],
+          messages: [...nonStatusMessages, ...messagesWithCitations],
           isLoading: false // Mark as complete since we have the final response
         });
 
@@ -1082,6 +1112,14 @@ export class SecureChatClientImpl implements SecureChatClient {
     this.querySuccessCallback = callback;
   }
 
+  clearCitations() {
+    this.currentRequestCitations = [];
+  }
+
+  getCurrentRunId() {
+    return this.currentQueryRunId;
+  }
+
   cleanup() {
     if (this.eventSource) {
       this.eventSource.close();
diff --git a/frontend-app/utils/services/langGraphStreamingService.ts b/frontend-app/utils/services/langGraphStreamingService.ts
index 8759a77..87663f4 100644
--- a/frontend-app/utils/services/langGraphStreamingService.ts
+++ b/frontend-app/utils/services/langGraphStreamingService.ts
@@ -359,13 +359,17 @@ export class LangGraphStreamingService {
       const nodeName = Object.keys(data)[0];
       const nodeData = data[nodeName];
       
+      // Extract citations from tool responses in updates
+      const citations = this.extractCitationsFromToolResponses(data);
+      
       // console.log('[LangGraphStreamingService] Node update:', nodeName);
       
       return {
         type: 'node_update',
         data: { nodeName, nodeData },
         nodeName: nodeName,
-        streamMode: 'updates'
+        streamMode: 'updates',
+        metadata: { citations }
       };
     }
     
@@ -373,6 +377,15 @@ export class LangGraphStreamingService {
     if (event === 'messages' && Array.isArray(data)) {
       // console.log('[LangGraphStreamingService] Processing messages event with', data.length, 'items');
       
+      // Extract citations from all messages (including tool responses)
+      const allCitations: string[] = [];
+      data.forEach((item: any) => {
+        if (item && typeof item === 'object' && item.content) {
+          const citations = this.extractCitationsFromMessage(item);
+          allCitations.push(...citations);
+        }
+      });
+      
       // Filter for AI messages from Clera
       const aiMessages = data.filter((item: any) => 
         item && 
@@ -385,14 +398,25 @@ export class LangGraphStreamingService {
       if (aiMessages.length > 0) {
         // console.log('[LangGraphStreamingService] Found', aiMessages.length, 'AI messages from Clera');
         
+        // Clean up citation markers from the message content
+        const cleanedMessages = aiMessages.map((msg: any) => {
+          if (msg.content && typeof msg.content === 'string') {
+            // Remove citation markers from content
+            const cleanedContent = msg.content.replace(/<!-- CITATIONS: [^>]+ -->/g, '').trim();
+            return { ...msg, content: cleanedContent };
+          }
+          return msg;
+        });
+        
         // CRITICAL FIX: Use 'messages_complete' type to trigger status message removal in frontend
         return { 
           type: 'messages_complete',
-          data: aiMessages,
+          data: cleanedMessages,
           metadata: { 
             event, 
-            messageCount: aiMessages.length,
-            isCompleteResponse: true
+            messageCount: cleanedMessages.length,
+            isCompleteResponse: true,
+            citations: allCitations
           }
         };
       } else {
@@ -400,7 +424,7 @@ export class LangGraphStreamingService {
         return { 
           type: 'messages_metadata',
           data: data,
-          metadata: { event, messageCount: data.length }
+          metadata: { event, messageCount: data.length, citations: allCitations }
         };
       }
     }
@@ -447,6 +471,85 @@ export class LangGraphStreamingService {
     return { type: 'metadata', data: data };
   }
 
+  /**
+   * Extracts citations from a message by parsing special citation markers
+   * 
+   * @param message The message object to extract citations from
+   * @returns Array of citation URLs
+   */
+  private extractCitationsFromMessage(message: any): string[] {
+    if (!message || !message.content) return [];
+    
+    const content = message.content;
+    const citations: string[] = [];
+    
+    // Ensure content is a string
+    if (typeof content !== 'string') {
+      console.warn('[LangGraphStreamingService] Content is not a string:', typeof content, content);
+      return [];
+    }
+    
+    // First, try to extract citations from special markers (new approach)
+    const citationMarkerRegex = /<!-- CITATIONS: ([^>]+) -->/;
+    const markerMatch = content.match(citationMarkerRegex);
+    
+    if (markerMatch && markerMatch[1]) {
+      // Split by comma and clean up URLs
+      const citationUrls = markerMatch[1].split(',').map((url: string) => url.trim()).filter((url: string) => url);
+      citations.push(...citationUrls);
+    }
+    
+    // Fallback: Extract markdown links in the format [1](url), [2](url), etc.
+    if (citations.length === 0) {
+      const linkRegex = /\[(\d+)\]\(([^)]+)\)/g;
+      let match;
+      
+      while ((match = linkRegex.exec(content)) !== null) {
+        const url = match[2];
+        if (url && !citations.includes(url)) {
+          citations.push(url);
+        }
+      }
+    }
+    
+    return citations;
+  }
+
+  /**
+   * Extracts citations from tool responses in updates
+   * 
+   * @param data The data object from updates event
+   * @returns Array of citation URLs
+   */
+  private extractCitationsFromToolResponses(data: any): string[] {
+    const citations: string[] = [];
+    
+    if (!data || typeof data !== 'object') return citations;
+    
+    // Look through all node data for tool responses
+    Object.values(data).forEach((nodeData: any) => {
+      if (nodeData && typeof nodeData === 'object') {
+        // Check if this node has messages with tool responses
+        if (Array.isArray(nodeData.messages)) {
+          nodeData.messages.forEach((msg: any) => {
+            if (msg && typeof msg === 'object' && msg.content) {
+              const msgCitations = this.extractCitationsFromMessage(msg);
+              citations.push(...msgCitations);
+            }
+          });
+        }
+        
+        // Check if this node has tool results
+        if (nodeData.tool_result && typeof nodeData.tool_result === 'string') {
+          const toolCitations = this.extractCitationsFromMessage({ content: nodeData.tool_result });
+          citations.push(...toolCitations);
+        }
+      }
+    });
+    
+    return citations;
+  }
+
   /**
    * Attempts to extract tool/agent events from raw LangGraph chunk
    * and convert them into UI-friendly events:
diff --git a/verify_citations_fix.md b/verify_citations_fix.md
new file mode 100644
index 0000000..c9821a7
--- /dev/null
+++ b/verify_citations_fix.md
@@ -0,0 +1,81 @@
+# Citations Fix Verification
+
+## Summary of Changes Made
+
+### 1. Backend Changes
+- **File**: `frontend-app/utils/services/langGraphStreamingService.ts`
+  - Added `extractCitationsFromToolResponses()` method to extract citations from tool responses
+  - Modified `processStreamChunk()` to extract citations from all messages (including tool responses)
+  - Updated node update processing to include citations in metadata
+
+### 2. Frontend Changes
+- **File**: `frontend-app/utils/api/secure-chat-client.ts`
+  - Added citation accumulation logic to handle citations from multiple chunks
+  - Updated node update handling to extract citations from tool responses
+  - Fixed Set iteration issues for better compatibility
+
+- **File**: `frontend-app/components/chat/Chat.tsx`
+  - Added auto-show logic for SourcesTab when citations are available
+  - Added useEffect to automatically display sources when citations are present
+
+### 3. Root Cause Analysis
+The issue was that citations were being embedded in tool response text as HTML comments (`<!-- CITATIONS: url1,url2,url3 -->`), but the streaming service was only looking for citations in the final AI message, not in tool responses.
+
+### 4. Solution Implemented
+1. **Tool Response Processing**: Modified the streaming service to extract citations from all messages, including tool responses
+2. **Citation Accumulation**: Updated the secure chat client to accumulate citations from all chunks
+3. **UI Integration**: Added auto-show logic for the SourcesTab when citations are available
+4. **Metadata Flow**: Ensured citations flow through the metadata system from backend to frontend
+
+## How to Test
+
+### Manual Testing Steps:
+1. Start the backend server
+2. Start the frontend application
+3. Ask a question that triggers web search (e.g., "What's the latest news on Apple stock?")
+4. Verify that:
+   - The web search tool is called
+   - Citations are extracted from the tool response
+   - The SourcesTab appears automatically
+   - Citations are displayed in the SourcesTab
+   - Each citation is clickable and opens in a new tab
+
+### Expected Behavior:
+- When a web search is performed, citations should be automatically extracted
+- The SourcesTab should appear at the bottom of the chat
+- Citations should be displayed with proper formatting
+- Users can click on citations to visit the source URLs
+
+## Technical Details
+
+### Citation Extraction Flow:
+1. **Web Search Tool** (`financial_analyst_agent.py`):
+   - Gets citations from Perplexity API response
+   - Embeds them as HTML comments in the response text
+   - Returns clean text with citation markers
+
+2. **Streaming Service** (`langGraphStreamingService.ts`):
+   - Extracts citations from all messages (including tool responses)
+   - Passes citations through metadata
+   - Cleans citation markers from display text
+
+3. **Chat Client** (`secure-chat-client.ts`):
+   - Accumulates citations from all chunks
+   - Stores citations in state
+   - Passes citations to UI components
+
+4. **UI Components** (`Chat.tsx`, `SourcesTab.tsx`):
+   - Displays citations in a ChatGPT-style sources tab
+   - Auto-shows sources when citations are available
+   - Provides clickable links to source URLs
+
+## Performance Considerations
+- Citation extraction is lightweight and doesn't impact search time
+- Citations are processed asynchronously and don't block the main response
+- The auto-show feature provides good UX without being intrusive
+
+## Compatibility
+- Maintains compatibility with existing features
+- No breaking changes to the API
+- Preserves existing search functionality
+- Works with both streaming and non-streaming responses
